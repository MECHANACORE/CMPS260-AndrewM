<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>CMPS 260: Module 9 Homework</title>
  <style>
    * {
      font-family: monospace;
    }
  </style>
  <script>
    //-------------------------//
    // The tree data structure //
    //-------------------------//
    console.log("The tree data structure");

    // Skip.



    //------------------//
    // Tree terminology //
    //------------------//
    console.log("Tree terminology");

    // Skip.



    //------------------------------------//
    // The binary and binary search trees //
    //------------------------------------//
    console.log("The binary and binary search trees");
    function BinarySearchTree() {
      function Node(key) {
        this.key = key;
        this.left = null;
        this.right = null
      }


      // the root node
      this.root = null;
    }

    // helper functions
    BinarySearchTree.prototype._insertNode = function (node, newNode) {
      // node is the node we want to insert into
      // newNode is the node we want to insert
      if (newNode.key < node.key) {
        // go to left
        if (node.left === null) {
          // no left node yet so assign
          node.left = newNode;
        }
        else {
          // move down tree and repeat
          this._insertNode(node.left, newNode);
        }
      }
      else {
        // go to right
        if (node.right === null) {
          // no right node yet so assign
          node.right = newNode;
        }
        else {
          // move down tree and repeat
          this._insertNode(node.right, newNode);
        }
      }
    }

    BinarySearchTree.prototype.insert = function (key) {
      // insert new key in the tree
      var newNode = new Node(key);
      if (root === null) {
        // no nodes yet
        root = newNode;
      }
      else {
        // find insert location through insertNode
        this._insertNode(root, newNode);
      }
    };

    // 1. Finish the implementation of the tree data structure above using the
    //    prototype (as opposed to the version we wrote in class). Note that we
    //    have helper functions that we have to deal with, and we simply make them
    //    part of the prototype but prepend them with _, e.g., _insertNode above.
    //    This is a common convention/solution. Programmers using a tree object are
    //    not supposed to use _ methods (or properties) directly.
    var tree = new BinarySearchTree();
    tree.insert(11);
    tree.insert(7);
    tree.insert(15);
    tree.insert(5);
    tree.insert(3);
    tree.insert(9);
    tree.insert(8);
    tree.insert(10);
    tree.insert(13);
    tree.insert(12);
    tree.insert(14);
    tree.insert(20);
    tree.insert(18);
    tree.insert(25);
    tree.insert(6);
    // 2. Run some tests that show that your code works.
    tree.print();


    //----------------//
    // Tree traversal //
    //----------------//
    console.log("Tree traversal");

    function printNode(value) {
      console.log(value);
    }

    // 1. Implement in-order traversal using the prototype. Test your
    //    implementation with the printNode() function given above.
    //    NOTE: in-order means all keys are visited in sorted order.
    console.log("in order");
    tree.inOrderTraverse(printNode);
    // 2. Implement pre-order traversal using the prototype. Test your
    //    implementation with the printNode() function given above.
    //    NOTE: pre-order means a node is visited prior to its descendants.
    console.log("pre order");
    tree.preOrderTraverse(printNode);
    // 3. Implement post-order traversal using the prototype. Test your
    //    implementation with the printNode() function given above.
    //    NOTE: pre-order means a node is visited after its descendants.

    console.log("post order");
    tree.postOrderTraverse(printNode);

    //--------------------------------//
    // Searching for values in a tree //
    //--------------------------------//
    console.log("Searching for values in a tree");

    // 1. Implement the min method using the prototype and show that it works.
    console.log("tree.min(): " + tree.min());
    // 2. Implement the max method using the prototype and show that it works.
    console.log("tree.max(): " + tree.max());
    // 3. Implement the search method using the prototype and show that it works.
    console.log("tree.search(1): " + tree.search(1));
    console.log("tree.search(8): " + tree.search(8));
    // 4. Implement the remove method using the prototype and show that it works.
    this.remove = function (key) {

    };
    // Skip.



    //----------------------//
    // Self-balancing trees //
    //----------------------//
    console.log("Self-balancing trees");

    // Skip.



    //---------//
    // Project //
    //---------//
    console.log("Project");

    // 1. Create the tree that is given in the book if you haven't done so yet.
    //    NOTE: Use the one given right before the Tree Traversal section that
    //          includes the 6.
    function BinarySearchTree() {
      var Node = function (key) {
        this.key = key;
        this.left = null;
        this.right = null;
      };
      var root = null;
    }
    this.insert = function (key) {
      var newNode = new Node(key);
      if (root === null) {
        root = newNode;
      } else {
        insertNode(root, newNode);
      }
    };
    var insertNode = function (node, newNode) {
      if (newNode.key < node.key) {
        if (node.left === null) {
          node.left = newNode;
        } else {
          insertNode(node.left, newNode);
        }
      } else {
        if (node.right === null) {
          node.right = newNode;
        } else {
          insertNode(node.right, newNode);
        }
      }
    };
    var tree = new BinarySearchTree();
    tree.insert(11);
    tree.insert(7);
    tree.insert(15);
    tree.insert(5);
    tree.insert(3);
    tree.insert(9);
    tree.insert(8);
    tree.insert(10);
    tree.insert(13);
    tree.insert(12);
    tree.insert(14);
    tree.insert(20);
    tree.insert(18);
    tree.insert(25);
    tree.insert(6);
    // 2. We want to make a copy of this tree, but want to make sure that the copy
    //    we create is also nicely balanced (since we did not implement AVL). We
    //    can use in-order, pre-order, and post-order traversal to retrieve the
    //    nodes. If we want the new tree to be balanced as well, which order should
    //    we use if we want to insert the nodes in the new tree?
    function inOrderTraverseNode(node, callback) {
      if (node !== null) {
        inOrderTraverseNode(node.left, callback);
        callback(node.key);
        inOrderTraverseNode(node.right, callback);
      }
    }

    this.inOrderTraverse = function (callback) {
      inOrderTraverseNode(root, callback);
    };

    function preOrderTraverseNode(node, callback) {
      if (node !== null) {
        callback(node.key);
        preOrderTraverseNode(node.left, callback);
        preOrderTraverseNode(node.right, callback);
      }
    }

    this.preOrderTraverse = function (callback) {
      preOrderTraverseNode(root, callback);
    };

    function postOrderTraverseNode(node, callback) {
      if (node !== null) {
        postOrderTraverseNode(node.left, callback);
        postOrderTraverseNode(node.right, callback);
        callback(node.key);
      }
    }

    this.postOrderTraverse = function (callback) {
      postOrderTraverseNode(root, callback);
    };

    // 3. Run the traversal approach you picked in (2) to collect all the keys and
    //    store them in an array.
    console.log("pre order");
    tree.preOrderTraverse(printNode);
    // 4. Iterate through the array and insert each element inside a new tree. make
    //    sure it is balanced.
    var insertNode = function (node, element) {
      if (node === null) {
        node = new Node(element);
      } else if (element < node.key) {
        node.left = insertNode(node.left, element);
        if (node.left !== null) 
      } else if (element > node.key) {
        node.right = insertNode(node.right, element);
        if (node.right !== null) 
      }
      return node;
    };


  </script>
</head>

<body>
  See console!
</body>

</html>